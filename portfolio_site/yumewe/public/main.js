const socket = io();
let isBuffering = false; // True if THIS local player is currently buffering
let shouldResumeAfterBuffering = false; // Flag to indicate if WE should resume playback after a peer unbuffers
let otherUserBuffering = false; // True if the OTHER peer is currently buffering
let lastKnownPeerTime = 0; // To store the last known time from the peer for better seeking
let isPlayingGlobally = false; // A global state flag to manage playback across peers
let lastTimeEmitted = 0; // To control how frequently 'video-play' time updates are sent
let suppressEmit = false; // Prevent feedback loop during remote sync
let playRequestedWhileLoading = false; // Flag to track if play was requested while the video was loading

// WebRTC related variables
let localStream;
let peerConnection;
const remoteVideo = document.getElementById("liveVideo2"); // Element to display remote camera feed

document.addEventListener("DOMContentLoaded", () => {
  async function startUserCamera() {
    try {
      // Request both video AND audio for the local stream
      const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      document.getElementById("liveVideo1").srcObject = stream;
      localStream = stream; // Store the local stream

      // Create the RTCPeerConnection and add local tracks
      createPeerConnection();
      localStream
        .getTracks()
        .forEach((track) => peerConnection.addTrack(track, localStream));
      console.log("Local camera started and tracks added to peer connection.");
    } catch (error) {
      console.error("Error accessing camera:", error);
      // Display a user-friendly message on the UI instead of just console logging
      const vcContainer = document.getElementById("vc_container");
      if (vcContainer) {
        const errorMsg = document.createElement("p");
        errorMsg.textContent =
          "Could not access camera. Please ensure it's connected and permissions are granted.";
        errorMsg.style.color = "red";
        errorMsg.style.textAlign = "center";
        vcContainer.parentNode.insertBefore(errorMsg, vcContainer);
      }
    }
  }

  startUserCamera(); // Initiate camera access and WebRTC setup on DOMContentLoaded
});

// Function to create and configure the RTCPeerConnection
function createPeerConnection() {
  const configuration = {
    // Google's STUN server is a public server used to help peers discover their public IP addresses
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
  };
  peerConnection = new RTCPeerConnection(configuration);
  console.log("RTCPeerConnection created.");

  // Handler for when ICE candidates are generated by the peer connection
  // These candidates are network addresses that WebRTC will try to use to use to connect
  peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
      // Send the generated ICE candidate to the other peer via the signaling server
      socket.emit("ice-candidate", event.candidate);
      console.log("Emitting ICE candidate:", event.candidate);
    }
  };

  // Handler for when remote tracks (audio/video) are received from the other peer
  peerConnection.ontrack = (event) => {
    // Check if the remote video element is not already displaying this stream
    if (remoteVideo.srcObject !== event.streams[0]) {
      remoteVideo.srcObject = event.streams[0];
      console.log("Received remote stream, displaying on liveVideo2.");
    }
  };

  // Handler for when an SDP offer/answer needs to be created or renegotiated
  peerConnection.onnegotiationneeded = async () => {
    try {
      // Create an SDP offer describing our media capabilities
      const offer = await peerConnection.createOffer();
      // Set the generated offer as the local description for this peer connection
      await peerConnection.setLocalDescription(offer);
      // Send the offer to the other peer via the signaling server
      socket.emit("offer", peerConnection.localDescription);
      console.log("Emitting SDP offer:", peerConnection.localDescription);
    } catch (e) {
      console.error("Error creating offer:", e);
    }
  };
}

// Socket.IO listeners for WebRTC signaling messages

// Listener for incoming SDP Offers from another peer
socket.on("offer", async (description) => {
  // If peerConnection hasn't been created yet (e.g., this peer is the answering peer)
  if (!peerConnection) {
    createPeerConnection();
    // Ensure local tracks are added for the answering peer too
    if (localStream) {
      localStream
        .getTracks()
        .forEach((track) => peerConnection.addTrack(track, localStream));
      console.log("Local tracks added for answering peer.");
    }
  }
  console.log("Received SDP offer.");
  // Set the received offer as the remote description for this peer connection
  await peerConnection.setRemoteDescription(description);
  // Create an SDP answer in response to the offer
  const answer = await peerConnection.createAnswer();
  // Set the generated answer as the local description
  await peerConnection.setLocalDescription(answer);
  // Send the answer back to the initiating peer via the signaling server
  socket.emit("answer", peerConnection.localDescription);
  console.log("Emitting SDP answer:", peerConnection.localDescription);
});

// Listener for incoming SDP Answers from another peer
socket.on("answer", async (description) => {
  console.log("Received SDP answer.");
  // Set the received answer as the remote description for this peer connection
  await peerConnection.setRemoteDescription(description);
});

// Listener for incoming ICE Candidates from another peer
socket.on("ice-candidate", async (candidate) => {
  try {
    console.log("Received ICE candidate.");
    // Add the received ICE candidate to the peer connection
    await peerConnection.addIceCandidate(candidate);
  } catch (e) {
    console.error("Error adding received ICE candidate:", e);
  }
});

// --- Movie Player Logic with Robust Synchronization ---

const movieBox = document.getElementById("movie");
const moviePlayer = document.getElementById("moviePlayer");
const videoUploader = document.getElementById("videoUploader"); // Get the file input element

// Prevent default drag behaviors for the movie box
["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
  movieBox.addEventListener(eventName, (e) => e.preventDefault());
});

// Highlight movie box on dragover
movieBox.addEventListener("dragover", () => {
  movieBox.style.borderBlockColor = "green";
});

// Reset movie box border on dragleave or drop
["dragleave", "drop"].forEach((eventName) => {
  movieBox.addEventListener(eventName, () => {
    movieBox.style.borderBlockColor = "black";
  });
});

// Handle file drop event for the movie box OR file input change
function handleVideoFile(file) {
  if (file && file.type.startsWith("video/")) {
    console.log(
      "Video file selected:",
      file.name,
      "Type:",
      file.type,
      "Size:",
      file.size,
      "bytes"
    );

    // Display local video immediately for feedback
    const localVideoURL = URL.createObjectURL(file);
    moviePlayer.src = localVideoURL;
    moviePlayer.load();

    moviePlayer.oncanplay = () => {
      moviePlayer.oncanplay = null;
      moviePlayer.play().catch((error) => {
        console.error(
          "Error playing video locally (after setting src):",
          error
        );
        const messageDiv = document.createElement("div");
        messageDiv.textContent = `Error playing video locally: ${error.message}.`;
        messageDiv.style.color = "red";
        messageDiv.style.marginTop = "10px";
        messageDiv.style.textAlign = "center";
        movieBox.parentNode.insertBefore(messageDiv, movieBox.nextSibling);
        setTimeout(() => messageDiv.remove(), 5000);
      });
    };

    // Upload the video file to the server using Fetch API
    const formData = new FormData();
    formData.append("videoFile", file); // 'videoFile' matches the name in server.js upload.single()

    console.log("Uploading video file to server...");
    fetch("/upload-video", {
      method: "POST",
      body: formData,
    })
      .then((response) => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then((data) => {
        if (data.success) {
          console.log(
            "Video uploaded successfully. Server URL:",
            data.videoURL
          );
          // Server will emit "video-share" to all clients, including this one.
          // No need to emit from client directly here anymore.
        } else {
          console.error("Server reported upload failure:", data.message);
          const messageDiv = document.createElement("div");
          messageDiv.textContent = `Video upload failed: ${data.message}.`;
          messageDiv.style.color = "red";
          messageDiv.style.marginTop = "10px";
          messageDiv.style.textAlign = "center";
          movieBox.parentNode.insertBefore(messageDiv, movieBox.nextSibling);
          setTimeout(() => messageDiv.remove(), 5000);
        }
      })
      .catch((error) => {
        console.error("Error during video upload fetch:", error);
        const messageDiv = document.createElement("div");
        messageDiv.textContent = `Network error during upload: ${error.message}.`;
        messageDiv.style.color = "red";
        messageDiv.style.marginTop = "10px";
        messageDiv.style.textAlign = "center";
        movieBox.parentNode.insertBefore(messageDiv, movieBox.nextSibling);
        setTimeout(() => messageDiv.remove(), 5000);
      });
  } else {
    const messageDiv = document.createElement("div");
    messageDiv.textContent = "Please select a video file!";
    messageDiv.style.color = "red";
    messageDiv.style.marginTop = "10px";
    messageDiv.style.textAlign = "center";
    movieBox.parentNode.insertBefore(messageDiv, movieBox.nextSibling);
    setTimeout(() => messageDiv.remove(), 3000);
  }
}

// Listen for drop event
movieBox.addEventListener("drop", (e) => {
  handleVideoFile(e.dataTransfer.files[0]);
});

// Listen for file input change event (for direct file selection)
videoUploader.addEventListener("change", (e) => {
  handleVideoFile(e.target.files[0]);
});

// Listener for when another user shares a video (now receives a URL from server)
socket.on("video-share", (videoURL) => {
  console.log(
    `Received 'video-share' from peer/server. Video URL: ${videoURL}`
  );
  moviePlayer.src = videoURL;
  moviePlayer.load();
  playRequestedWhileLoading = false;

  // Attempt to play if the shared state is currently playing
  if (isPlayingGlobally) {
    playRequestedWhileLoading = true;
  } else {
    console.log(
      "Shared video loaded, but not playing due to global state (paused)."
    );
  }
});

// Emit playback state and current time more robustly
moviePlayer.addEventListener("play", () => {
  if (suppressEmit) {
    suppressEmit = false;
    return;
  }
  if (!isBuffering && !otherUserBuffering) {
    isPlayingGlobally = true;
    console.log(
      `Movie player PLAY event. Current time: ${moviePlayer.currentTime}. Emitting 'video-play'.`
    );
    socket.emit("video-play", moviePlayer.currentTime);
  } else {
    console.log(
      "PLAY event triggered but buffering detected, not emitting sync."
    );
  }
});

moviePlayer.addEventListener("pause", () => {
  if (suppressEmit) {
    suppressEmit = false;
    return;
  }
  isPlayingGlobally = false;
  console.log(
    `Movie player PAUSE event. Current time: ${moviePlayer.currentTime}. Emitting 'video-pause'.`
  );
  socket.emit("video-pause", moviePlayer.currentTime);
});

// Using timeupdate for continuous sync, but with a threshold
moviePlayer.addEventListener("timeupdate", () => {
  // Only emit if playing and time has changed significantly since last emit
  if (
    !moviePlayer.paused &&
    Math.abs(moviePlayer.currentTime - lastTimeEmitted) > 1 &&
    !isBuffering &&
    !otherUserBuffering
  ) {
    socket.emit("video-play", moviePlayer.currentTime);
    lastTimeEmitted = moviePlayer.currentTime;
    // console.log(`Timeupdate sync: ${moviePlayer.currentTime}`); // Can be very chatty
  }
});

moviePlayer.addEventListener("seeked", () => {
  if (suppressEmit) {
    suppressEmit = false;
    return;
  }
  console.log(
    `Movie player SEEKED event. Current time: ${moviePlayer.currentTime}. Emitting 'video-seek'.`
  );
  socket.emit("video-seek", moviePlayer.currentTime);
});

// Add listeners for media state changes for more detailed debugging
moviePlayer.addEventListener("canplay", () => {
  console.log("Movie player CANPLAY event: Media is ready to play.");
  if ((isPlayingGlobally || playRequestedWhileLoading) && moviePlayer.paused) {
    suppressEmit = true;
    moviePlayer.play().catch((e) => {
      console.error("Error playing after canplay:", e);
    });
    playRequestedWhileLoading = false;
  }
});
moviePlayer.addEventListener("canplaythrough", () => {
  console.log(
    "Movie player CANPLAYTHROUGH event: Media likely to play to end without interruption."
  );
});
moviePlayer.addEventListener("ended", () => {
  console.log("Movie player ENDED event: Video has finished playing.");
  isPlayingGlobally = false; // Video ended, update global state
  socket.emit("video-pause", moviePlayer.currentTime); // Inform peers it ended
});
moviePlayer.addEventListener("error", (e) => {
  console.error("Movie player ERROR event:", e);
  isPlayingGlobally = false; // Error occurred, stop trying to play
  const messageDiv = document.createElement("div");
  messageDiv.textContent = `Video Playback Error: ${
    e.message || "Unknown error"
  }. It might be corrupted or too large.`;
  messageDiv.style.color = "red";
  messageDiv.style.marginTop = "10px";
  messageDiv.style.textAlign = "center";
  movieBox.parentNode.insertBefore(messageDiv, movieBox.nextSibling);
  setTimeout(() => messageDiv.remove(), 5000);
});

// Handle incoming video playback events from other users
socket.on("video-play", (time) => {
  console.log(
    `Received 'video-play' from peer. Requested time: ${time}. Player paused: ${moviePlayer.paused}, otherUserBuffering: ${otherUserBuffering}, isBuffering: ${isBuffering}`
  );
  lastKnownPeerTime = time;
  isPlayingGlobally = true;

  // Seek if needed
  if (Math.abs(moviePlayer.currentTime - time) > 1) {
    moviePlayer.currentTime = time;
    console.log(`Seeked to ${time} due to play sync.`);
  }

  // Only play if the video is not already playing, not buffering, and the readyState is sufficient
  if (moviePlayer.readyState < 2) {
    playRequestedWhileLoading = true;
    return;
  }
  if (moviePlayer.paused && !isBuffering && !otherUserBuffering) {
    suppressEmit = true; // Prevent feedback loop
    moviePlayer
      .play()
      .catch((e) => console.error("Error playing after play sync:", e));
  }
});

socket.on("video-pause", (time) => {
  console.log(
    `Received 'video-pause' from peer. Requested time: ${time}. Player paused: ${moviePlayer.paused}, otherUserBuffering: ${otherUserBuffering}, isBuffering: ${isBuffering}`
  );
  lastKnownPeerTime = time;
  isPlayingGlobally = false;
  if (Math.abs(moviePlayer.currentTime - time) > 1) {
    moviePlayer.currentTime = time;
    console.log(`Seeked to ${time} due to pause sync.`);
  }

  if (!moviePlayer.paused) {
    suppressEmit = true;
    moviePlayer.pause();
  }
});

socket.on("video-seek", (time) => {
  console.log(`Received 'video-seek' from peer. Requested time: ${time}.`);
  lastKnownPeerTime = time; // Update last known peer time
  suppressEmit = true;
  moviePlayer.currentTime = time;
  // If seeking when globally playing, try to play after seek
  if (
    isPlayingGlobally &&
    moviePlayer.paused &&
    !isBuffering &&
    !otherUserBuffering
  ) {
    moviePlayer
      .play()
      .catch((e) => console.error("Error playing after seek sync:", e));
  }
});

// Handle buffering states for video synchronization
moviePlayer.addEventListener("waiting", () => {
  isBuffering = true;
  socket.emit("video-buffering", true);
  console.log(
    `Local movie player WAITING event. isBuffering: ${isBuffering}. Emitting 'video-buffering: true'.`
  );
  // If our player is buffering, pause regardless of global state for now
  moviePlayer.pause();
});

moviePlayer.addEventListener("playing", () => {
  if (isBuffering) {
    // Only act if we were previously buffering
    isBuffering = false;
    socket.emit("video-buffering", false);
    console.log(
      `Local movie player PLAYING event. isBuffering: ${isBuffering}. Emitting 'video-buffering: false'.`
    );
    // If we just stopped buffering and global state is playing, try to resume
    if (isPlayingGlobally && moviePlayer.paused && !otherUserBuffering) {
      moviePlayer
        .play()
        .catch((e) => console.error("Error resuming after local unbuffer:", e));
    }
  }
});

socket.on("video-buffering", (isBufferingNow) => {
  otherUserBuffering = isBufferingNow;
  console.log(
    `Received 'video-buffering' from peer: ${isBufferingNow}. Local isBuffering: ${isBuffering}, moviePlayer.paused: ${moviePlayer.paused}, shouldResumeAfterBuffering: ${shouldResumeAfterBuffering}, isPlayingGlobally: ${isPlayingGlobally}`
  );

  if (otherUserBuffering) {
    // If other user is buffering, and we are not currently paused, remember to resume later
    if (!moviePlayer.paused) {
      shouldResumeAfterBuffering = true;
      moviePlayer.pause(); // Pause our player
      console.log("Pausing local player because other user is buffering.");
    }
  } else {
    // Other user is no longer buffering
    // If we were supposed to resume and we are not locally buffering, and the other user is no longer buffering
    if (shouldResumeAfterBuffering && !isBuffering && isPlayingGlobally) {
      // Also check global state
      setTimeout(() => {
        moviePlayer
          .play()
          .catch((e) =>
            console.error("Error resuming after other user unbuffered:", e)
          );
        shouldResumeAfterBuffering = false; // Reset the flag
        console.log("Resuming local player because other user unbuffered.");
      }, 100); // 100ms delay
    }
  }
});
